#+TITLE: Personal Emacs Configuration
#+AUTHOR: Lorenzo Cabrini
#+PROPERTY: header-args :results silent :tangle "~/.config/emacs/init.el"
#+AUTO_TANGLE: t
#+FILETAGS: :emacs:config:

* Introduction
* Bootstrap
** Init File Header
There is an Emacs convention to add a special comment header to Lisp libraries (read about it [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html][here]]), so I do that here.

#+begin_src emacs-lisp
  ;;; init.el --- Emacs configuration -*- lexical-binding: t -*-

  ;;; Copyright (C) 2023 Lorenzo Cabrini

  ;;; Author: Lorenzo Cabrini <lorenzo.cabrini@gmail>
  ;;; Keywords: configuration
  ;;; URL: https://gitlab.com/lorenzocabrini/emacs.d

  ;;; Commentary:

  ;;; Code:
#+end_src
** Early Init
Emacs will read the contents of ~early-init.el~ if it is present. This happens before the package system
and the GUI are initialized, so it it a place to do early initialization stuff.

The following block of code gets tangled into ~~.config/emacs/early-init.el~.

#+begin_src emacs-lisp :tangle "~/.config/emacs/early-init.el"
  ;;; early-init.el --- Early initialization -*- lexical-binding: t -*-

  ;;; Copyright (C) 2023 Lorenzo Cabrini

  ;;; Author: Lorenzo Cabrini <lorenzo.cabrini@gmail>
  ;;; Keywords: configuration
  ;;; URL: https://gitlab.com/lorenzocabrini/emacs.d

  ;;; Commentary:

  ;;; Code:

  ;; Inhibit package.el loading packages prior to init.el loading
  (setq package-enable-at-startup nil)

  ;; Disable some GUI elements early so that they don't briefly show up when Emacs
  ;; first fires up
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  ;; Disable GUI elements
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq inhibit-splash-screen t)
  (setq use-file-dialog nil)

  (setq comp-deferred-compilation nil)
  ;;; early-init.el ends here
#+end_src
* Package Management
** Straight
 [[https://github.com/radian-software/straight.el][straight.el]] is a package manager. The following block of code, taken from the ~straight.el~ README, sets it up.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Make sure that ~straight.el~ is used as the default package manager.

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
#+end_src
*** Integration with ~use-package~
A popular macro for package installation and configuration is [[https://github.com/jwiegley/use-package][use-package]].  The following makes use-package use ~straight.el~ for package management.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
#+end_src
* General Settings
** Help
*** Which Key
The [[https://github.com/justbur/emacs-which-key][which-key]] utility shows possible completions of commands in the miniguffer.

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src
** Shell Path
The [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] package imports the shell environment into emacs.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :init
    (when (daemonp)
      (exec-path-from-shell-initialize)))
#+end_src
** Version Control
*** Magit
[[https://magit.vc/][Magit]] is an interface to [[https://git-scm.com/][Git]].

#+begin_src emacs-lisp
  (use-package magit)
#+end_src
** Terminal Emulation
*** Vterm
I use [[https://github.com/akermu/emacs-libvterm][vterm]] as my default terminal in Emacs.

#+begin_src emacs-lisp
  (use-package vterm
    :config
    (defun lorcab/vterm ()
      (interactive)
      (vterm t))
    :bind ("<s-return>" . lorcab/vterm))
#+end_src
** Project Management
*** Projectile
I use [[https://github.com/bbatsov/projectile][Projectile]] for project managment.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (projectile-mode +1))
#+end_src
** Windows, Buffers and Workspaces
*** Perspective
[[https://github.com/nex3/perspective-el][Perspective]] provides named workspaces for Emacs.

#+begin_src emacs-lisp
  (use-package perspective
    :bind
    ("C-x C-b" . persp-list-buffers)         
    :custom
    (persp-mode-prefix-key (kbd "C-x x"))
    :init
    (persp-mode))
#+end_src
*** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] allows me to easily switch between windows in Emacs

#+begin_src emacs-lisp
  (use-package ace-window
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 3.0)))))))
#+end_src
* Org Mode
** Basic Org Configuration
I use [[https://orgmode.org/][org-mode]] extensively. Set it up with a few reasonable defaults.

#+begin_src emacs-lisp
  (use-package org
    :straight (:type built-in)
    :init (setq org-startup-indented t
                org-startup-folded t
                org-hide-emphasis-markers t
                org-hide-leading-stars t))
#+end_src

I'm trying out a non-proportional font in ~org-mode~. I also enable word wrap.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'variable-pitch-mode)
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

I customize a few elements. Althought I'm using a non-proportional font in org-mode, I don't want that to apply to code blocks. Also, there are some ~org-mode~ elements I find difficult to read, so I customize them.

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(org-block ((t (:inherit fixed-pitch))))
   '(org-code ((t (:inherit (shadow fixed-pitch)))))
   '(org-document-info ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
   '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
   '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))
   '(org-date ((t (:inherit (shadow fixed-pitch))))))  
#+end_src
** Org Agenda
The agenda reports on tasks and their states. It needs to know in which files it should look for tasks. I want it to look in a few files in ~~/org/gtd/~. In addition, it should look in any file named ~README.org~ in any directory under ~~/git~.

#+begin_src emacs-lisp
  (defun lorcab/readme-in-dir-p (p)
    (let ((fp (expand-file-name "README.org" p)))
      (if (file-exists-p fp)
          fp)))

  (setq org-agenda-files
        (append
         '("~/org/gtd/projects.org" "~/org/gtd/habits.org")
         (flatten-tree
          (mapcar #'lorcab/readme-in-dir-p
                  (directory-files
                   "~/git"
                   t
                   directory-files-no-dot-files-regexp)))))
#+end_src
** Org Roam
[[https://www.orgroam.com/][Org-roam]] is an extension to ~org-mode~ that implments a personal knowledge management system.

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/org/roam")
    :bind
    (("C-c n l" . org-roam-buffer-toggle)
     ("C-c n f" . org-roam-node-find)
     ("C-c n i" . org-roam-node-insert))
    :config
    (org-roam-setup))
#+end_src
*** Org Roam UI
[[https://github.com/org-roam/org-roam-ui][org-roam-ui]] provide visualization of the ~org-roam~ database.

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :straight (:host github
                     :repo "org-roam/org-roam-ui"
                     :branch "main"
                     :files ("*.el" "out"))
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
** Org Modern
I'm trying out [[https://github.com/minad/org-modern][org-modern]], which gives a "modern" style to ~org-mode~.

#+begin_src emacs-lisp
  (use-package org-modern
    :custom
    (org-modern-table nil)
    (org-modern-timestamp nil)
    (org-modern-priority nil)
    :config
    (global-org-modern-mode))
#+end_src
** Org Auto Tangle
[[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]] is used to automatically tangle org files on save.

#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :hook org-mode)
#+end_src
* Text
** Fonts
Here I set the fonts I use. I'm probably going to try a few fonts out until I find something that works well for me.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "JetBrainsMono")
  (set-face-attribute 'fixed-pitch nil :font "JetBrainsMono")
  (set-face-attribute 'variable-pitch nil :font "DejaVu Sans")
#+end_src
** Completion
*** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode))
#+end_src
*** Marginalia
The [[https://github.com/minad/marginalia][Marginalia]] package provides marginalia to minibuffer completions.

#+begin_src emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode))
#+end_src
*** Orderless
The [[https://github.com/oantolin/orderless][orderless]] package gives an orderless completion style.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides
          '((file (styles partial-completion)))))

#+end_src
*** Corfu
[[https://github.com/minad/corfu][Corfu]] provides a completion popup for completion at point.

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-auto t)
    (corfu-separator ?\s)
    :init
    (global-corfu-mode))
#+end_src
*** Consult
[[https://github.com/minad/consult][Consult]] provides search and navigation commands. I'm currently getting familiar with it, so
this configuration is going to change over time.

#+begin_src emacs-lisp
  (use-package consult
    :bind
    ("M-s l" . consult-line)
    ("M-s L" . consult-line-multi))
#+end_src
** Ledger Mode
[[https://www.ledger-cli.org/][Ledger]] is a powerful personal accounting system for the command-line. Of course, there is a [[https://www.ledger-cli.org/3.0/doc/ledger-mode.html][ledger-mode]] for Emacs as well.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :init
    (setq ledger-clear-whole-transactions 1)
    :mode "\\.ledger\\'")
#+end_src
** Systemd Mode
I frequently edit systemd unit files, so [[https://github.com/holomorph/systemd-mode][systemd-mode]] is handy.

#+begin_src emacs-lisp
  (use-package systemd)
#+end_src
** Snippets
[[https://github.com/joaotavora/yasnippet][Yasnippet]] provides snippets from Emacs.

 #+begin_src emacs-lisp
   (use-package yasnippet
     :config
     (yas-global-mode 1))
 #+end_src
* UI
** All the Icons
The [[https://github.com/domtronn/all-the-icons.el][all-the-icons]] package is a utility package to install some icon fonts and use them within Emacs.

To install the actual fonts do:

#+begin_example
  M-x all-the-icons-install-fonts
#+end_example

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

The following package adds icon support to dired-mode.

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :after all-the-icons
    :hook
    (dired-mode . all-the-icons-dired-mode))
#+end_src
** Dashboard
Currently, I use [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] as my start-up buffer.

#+begin_src emacs-lisp
  (use-package dashboard
    :demand
    :config
    (dashboard-setup-startup-hook))

  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (setq dashboard-banner-logo-title nil)
  (setq dashboard-startup-banner 'official)
  (setq dashboard-center-content nil)
  (setq dashboard-set-navigator t)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  
  (setq dashboard-items '((recents  . 5)
                          (projects . 5)
                          (agenda . 5)))

  (setq dashboard-navigator-buttons
        `(
          ((,(all-the-icons-octicon "home" :height 1.1 :v-adjust 0.0)
            "Index"
            "Open index.org"
            (lambda (&rest _) (find-file "~/org/index.org")))
           (,(all-the-icons-faicon "gitlab" :height 1.1 :v-adjust 0.0)
            "GitLab"
            "Open GitLab"
            (lambda (&rest _) (browse-url "https://gitlab.com")))
           (,(all-the-icons-octicon "gear" :height 1.1 :v-adjust 0.0)
            "Config"
            "Emacs config"
            (lambda (&rest _) (find-file "~/git/emacs.d/README.org")))
           )))
#+end_src
** Theme
*** Dracula
I feel really comfortable with the [[https://github.com/dracula/emacs][dracula]] theme. Where I make any minor changes to the theme, it is because I'm having a hard time seeing some element.

#+begin_src emacs-lisp
  (use-package dracula-theme
    :init
    (setq dracula-enlarge-headings t)
    :config
    (load-theme 'dracula t)
    (set-face-background 'org-block "#1E2029"))
#+end_src
** Modeline
I use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] as my modeline.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init
    (doom-modeline-mode 1)
    :config
    (setq doom-modeline-icon t)
    (setq doom-modeline-buffer-file-name-style 'file-name)
    (column-number-mode t)
    :custom
    (display-battery-mode t))
#+end_src

Display the time on the modeline.

#+begin_src emacs-lisp
  (setq display-time-default-load-average nil)
  (setq display-time-24hr-format t)
  (display-time-mode t)
#+end_src
* Programming
** Eglot
[[https://github.com/joaotavora/eglot][Eglot]] is a client for the Language Server Protocol (LSP).

#+begin_src emacs-lisp
  (use-package eglot
    :defer t
    :config
    (setq read-process-output-max (* 1024 1024)))
#+end_src
** Go
[[https://github.com/dominikh/go-mode.el][go-mode]] provides a major mode for Go. I use it with  Eglot. It seems Eglot is not able to organize imports automatically, so I solve this by using ~goimports~. This can be installed with:

#+begin_example
  $ go install golang.org/x/tools/cmd/goimports@latest
#+end_example

#+begin_src emacs-lisp
  (setq gofmt-command "goimports")
  
  (use-package go-mode
    :config
    (add-hook 'go-mode-hook 'eglot-ensure)
    (add-hook 'before-save-hook 'gofmt-before-save))
#+end_src
** JSON
[[https://github.com/joshwnj/json-mode][json-mode]] provides a major mode for working with JSON files.

#+begin_src emacs-lisp
  (use-package json-mode)
#+end_src

* Communication
** Mail
I use [[https://github.com/djcb/mu][mu4e]] to read mails in Emacs.

#+begin_src emacs-lisp
  (use-package mu4e
    :config
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-maildir "~/mail/gmail")

    (setq mu4e-drafts-folder "/[Gmail]/Drafts")
    (setq mu4e-sent-folder "/[Gmail]/Sent")
    (setq mu4e-refile-folder "/[Gmail]/All Mail")
    (setq mu4e-trash-folder "/[Gmail]/Trash")

    (setq mu4e-maildir-shortcuts
          '(("/Inbox" . ?i)
            ("/[Gmail]/Sent Mail" . ?s)
            ("/[Gmail]/Trash" . ?t)
            ("/[Gmail]/All Mail" . ?a))))
#+end_src

#+begin_src emacs-lisp
  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it
        starttls-use-gnutls t
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-auth-credentials
        '(("smtp.gmail.com" 587 "lorenzo.cabrini@gmail.com" nil)))
#+end_src
* News & Feeds
** Elfeed
I use [[https://github.com/skeeto/elfeed][elfeed]] for subscribing to RSS feeds.

#+begin_src emacs-lisp
  (use-package elfeed)

  (global-set-key (kbd "C-x w") 'elfeed)
#+end_src

I use a nifty little utility called [[https://github.com/remyhonig/elfeed-org][elfeed-org]] to manage my feeds in an org-mode file.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :ensure t
    :init
    (elfeed-org))

  (setq rmh-elfeed-org-files (list "~/org/feeds.org"))
#+end_src
* Multimedia
** EMMS
I use [[https://www.gnu.org/software/emms/][EMMS]] for playing audio in Emacs. I haven't spent much time configuring it, however.

#+begin_src emacs-lisp
  (use-package emms
    :config
    (progn
      (emms-standard)
      (emms-default-players)
      (setq emms-playlist-buffer-name "EMMS"
            emms-source-file-default-directory "~/music/")))
#+end_src

Org-mode integration is done with [[https://github.com/jagrg/org-emms][org-emms]].

#+begin_src emacs-lisp
  (use-package org-emms)
#+end_src
* Snippet Library
** Go
Make sure the snippet directory for ~go-mode~ exists.

#+begin_src emacs-lisp
  (unless (file-directory-p "~/.config/emacs/snippets/go-mode")
    (make-directory "~/.config/emacs/snippets/go-mode"))
#+end_src

#+begin_src snippet :tangle "~/.config/emacs/snippets/go-mode/main"
  # -*- snippet -*-
  # name: func main()
  # key: _m
  # --
  func main() {
       $0
  }
#+end_src

